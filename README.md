A JSON parser generated by [typed bnf](https://github.com/thautwarm/typed-bnf), which gives your cross-language semantic actions, and static type checking before codeg generation, and **automatic type inference**!


You can copy all `.cs` files from this project to get a complete Json parser. Such parser produces a `JsonValue`, in case you needs to handle Json serialization for variant types:

```ocaml
interface JsonValue
class JInt : JsonValue
class JFloat : JsonValue
class JList : JsonValue
...
class JNull : JsonValue
```

## Running Code Generation

1. Install
    - `typed-bnf`(requires Python 3.10+!)
    - [dotnet](https://dotnet.microsoft.com/download/dotnet/5.0) runtime 4+
    - [antlr4](https://www.antlr.org/) command line tool
2. `bash build.sh`(see concrete commands at `build.sh`)
3. `dotnet run` to see the results.


Check out generated antlr g4 source at `testjson.g4`.


## Overview


```ocaml
shape token {
    Text : str
}

// Using type alias is a workaround for C# codegen.
// C# has no type alias so we cannot refer to types
// via language-independent names.
typealias list = System.Collections.Generic.List
typealias dict = System.Collections.Generic.Dictionary

// Some declarations. They will specify what you need
// to provide for compiling this grammar.
val nil : forall 'a. () -> list['a]
val append : forall 'a. (list['a], 'a) -> list['a]
val mk_dict: forall 'k 'v. (list[('k, 'v)]) -> dict['k, 'v]
val parse_int: (str) -> int
val parse_float: (str) -> float
val unesc_string: (str) -> str
val json_list: (list[json]) -> json
val json_dict: (dict[str, json]) -> json
val json_int : (int) -> json
val json_float : (float) -> json
val json_string : (str) -> json
val json_null : () -> json

start : json      { $1 }


// parametric nonterminal rules!
list[a] : list[a] a     { append($1, $2) }
        | a { append(nil(), $1) }
        |  { nil() }

seplist[sep, elt] : seplist[sep, elt] sep elt  { append($1, $3) }
                  | elt { append(nil(), $1) }
                  | { nil() }

str : <str> { $1.Text }
pair : str ":" json   { ($1, $3) }


json : "[" seplist[",", json] "]" { json_list($2) }
| "{" seplist[",", pair] "}" { json_dict(mk_dict($2)) }
| <int>             { json_int(parse_int($1.Text)) }
| <FLOAT>           { json_float(parse_float($1.Text)) }
| str               { json_string(unesc_string($1)) }
| "null"            { json_null() }

%ignore <ws>


<ESCAPED_QUOTE> : "\\\""
<str> :   "\"" ( ESCAPED_QUOTE | !"\"")* "\""
<ws> : ("\r" | "\t" | "\n" | " ")
<int> : DIGIT+
<DIGIT> : [0 .. 9]
<FLOAT> : int "." int
```

You can check `JsonParse.cs` to see how we interface with the Antlr4-generated parser.
